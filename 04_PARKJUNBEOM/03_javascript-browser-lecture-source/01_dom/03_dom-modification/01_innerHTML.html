<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="area">노드 정보 취득</div>
    <script>
      console.log(document.nodeType);
      console.log(document.nodeName);
      const $area = document.getElementById("area");
      console.log($area.nodeType);
      console.log($area.nodeName);
      const $textNode = $area.firstChild;
      console.log($textNode.nodeType);
      console.log($textNode.nodeName);
    </script>

    <div id="area">nodeValue</div>
    <script>
      console.log(document.nodeValue);
      const $area2 = document.getElementById("area");
      console.log($area2.nodeValue);
      const $textNode2 = $area2.firstChild;
      console.log($textNode2.nodeValue);
      $textNode2.nodeValue = "텍스트 값 변경 완료!";
    </script>
    <div id="area2">textContent<span>내부 span</span></div>
    <script>
      const $area3 = document.getElementById("area2");
      // HTML의 마크업이 무시 된 div 내부의 컨텐츠를 텍스트로 취득
      console.log($area3.textContent);
      // nodeValue는 텍스트 노드의 값만 반환하므로 textContent보다 코드가 복잡해진다
      console.log($area3.nodeValue); // null
      console.log($area3.firstChild.nodeValue); // textContent
      console.log($area3.lastChild.firstChild.nodeValue); // 내부 span
      // area2의 모든 자식 노드가 제거 되고 할당한 문자열이 텍스트로 추가 된다.
      // HTML 마크업이 파싱되지 않는다.
      $area3.textContent = "텍스트 값 변경 완료!<span>내부 span</span>";
    </script>
    <pre>
      textContent프로퍼티는 HTML마크업을 무시하고 텍스트만 반환하지만 innerHTML 프로퍼티는
      HTML 마크업이 포함된 문자열을 그대로 반환한다.
    </pre>

    <div id="area4">
      태그 엘리먼트의 값을 읽거나, 변경할 때 <span>innerHTML</span> 속성을
      사용한다.
    </div>
    <script>
      const $area4 = document.getElementById("area4");
      console.log("area4.innerHTML", $area4.innerHTML);

      $area4.innerHTML += "값추가";

      $area4.innerHTML = "<h1>innerHTML</h> 속성으로 값변경";

      $area4.innerHTML = "";
    </script>
  </body>
</html>
